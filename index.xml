<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Estafette CI on Estafette CI/CD</title><link>https://estafette.io/</link><description>Recent content in Estafette CI on Estafette CI/CD</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://estafette.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Estafette CI extensions</title><link>https://estafette.io/usage/extensions/estafette-extensions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/usage/extensions/estafette-extensions/</guid><description>extensions/git-clone git-clone: image: extensions/git-clone:stable shallow: &amp;lt; boolean | true &amp;gt; The git-clone stage is automatically injected if not present in your manifest for the build stages; in the release stages it&amp;rsquo;s not injected. In case you don&amp;rsquo;t need anything from your repository to release this speeds things up.
The shallow clone - enabled by default - checks out the latest 50 commits for the particular branch, then selects the correct revision.</description></item><item><title>Goals</title><link>https://estafette.io/design/goals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/design/goals/</guid><description>The goals of Estafette CI are to&amp;hellip;
control builds and deployments from one concise manifest file. move control over build dependencies to the manifest file. control builds and deployments via cli, slack and web interface. give insight into build times, deployment times, failure rates and more. allow development teams to build their own extensions. support many concurrent builds by leveraging kubernetes jobs. provide resilience against failure during job execution. dogfood its own components by providing different tracks for each (dev, beta, stable/latest).</description></item><item><title>Installation</title><link>https://estafette.io/getting-started/installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/getting-started/installation/</guid><description>Installing Estafette CI Prerequisites:
install https://github.com/estafette/estafette-cloudflare-dns install https://github.com/estafette/estafette-letsencrypt-certificate install https://github.com/estafette/k8s-cockroachdb Configure cluster roles and binding:
curl https://raw.githubusercontent.com/estafette/estafette-ci-api/master/rbac.yaml -o rbac.yaml export NAMESPACE=estafette export APP_NAME=estafette-ci-api kubectl apply -f rbac.yaml Install the API:
curl https://raw.githubusercontent.com/estafette/estafette-ci-api/master/kubernetes.yaml -o kubernetes.yaml export NAMESPACE=estafette export APP_NAME=estafette-ci-api export TEAM_NAME=tooling-team export HOSTNAMES=ci.estafette.io export CLOUDFLARE_IP_RANGES=103.21.244.0/22, 103.22.200.0/22, 103.31.4.0/22, 104.16.0.0/12, 108.162.192.0/18, 131.0.72.0/22, 141.101.64.0/18, 162.158.0.0/15, 172.64.0.0/13, 173.245.48.0/20, 188.114.96.0/20, 190.93.240.0/20, 197.234.240.0/22, 198.41.128.0/17 export GITHUB_APP_PRIVATE_KEY= export VERSION=123456 export GO_PIPELINE_LABEL=latest export CPU_REQUEST=10m export MEMORY_REQUEST=15Mi export CPU_LIMIT=200m export MEMORY_LIMIT=512Mi export GITHUB_APP_ID=1234 export GITHUB_APP_OAUTH_CLIENT_ID=ab3.</description></item><item><title>Manifest</title><link>https://estafette.io/usage/manifest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/usage/manifest/</guid><description>Estafette CI is manifest-controlled. That means each build and stage is controlled via the manifest. No more fiddling in a GUI to set up a pipeline.
Labels Your manifest usually starts with a set of labels; these labels are useful to quickly filter pipelines in the GUI or api, but it also helps for reusing the same application name in your build or release steps.
In the manifest labels can be specified within the labels section; you have full freedom to come up with additional keys for your labels:</description></item><item><title>Architecture</title><link>https://estafette.io/design/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/design/architecture/</guid><description>To do this Estafette CI is composed of the following applications:
estafette-ci-api estafette-ci-web estafette-ci-builder estafette-ci-db-migrator</description></item><item><title>Build an extension</title><link>https://estafette.io/usage/extensions/build-an-extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/usage/extensions/build-an-extension/</guid><description>An Estafette extension is in essence just a containerized application. What&amp;rsquo;s special is that it uses custom properties injected as environment variables to parameterize it&amp;rsquo;s behaviour.
In the example below all non-reserved properties are automatically turned into a environment variable prefixed with ESTAFETTE_EXTENSION_.
bake: image: extensions/docker:dev action: build repositories: - estafette In this example the action property is set as ESTAFETTE_EXTENSION_ACTION on the stage container; the repositories property is set as ESTAFETTE_EXTENSION_REPOSITORIES and it&amp;rsquo;s array items are joined into comma-separated value;</description></item><item><title>Configuration</title><link>https://estafette.io/getting-started/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/getting-started/configuration/</guid><description/></item><item><title>Best practices</title><link>https://estafette.io/usage/best-practices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/usage/best-practices/</guid><description>Pin image tags In order to keep your builds reproducible, even if you haven&amp;rsquo;t touched them for a year it&amp;rsquo;s best to pin the stage image tags as narrowly as possible (or at least major and minor to avoid adopting breaking changes). This will ensure you&amp;rsquo;re not wasting a day figuring out why your build is suddenly broken, when it turns out it&amp;rsquo;s the latest image tag of one of the used images is actually a different image now.</description></item><item><title>Examples</title><link>https://estafette.io/usage/examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/usage/examples/</guid><description>golang labels: app: my-application language: golang stages: build: image: golang:1.11.2-alpine3.8 workDir: /go/src/github.com/estafette/${ESTAFETTE_LABEL_APP} env: CGO_ENABLED: 0 GOOS: linux commands: - go test `go list ./... | grep -v /vendor/` - CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags &amp;#34;-X main.version=${ESTAFETTE_BUILD_VERSION} -X main.revision=${ESTAFETTE_GIT_REVISION} -X main.branch=${ESTAFETTE_GIT_BRANCH} -X main.buildDate=${ESTAFETTE_BUILD_DATETIME}&amp;#34; -o ./publish/${ESTAFETTE_LABEL_APP} . csharp .net core labels: app: my-application language: dotnet-core stages: restore: image: microsoft/dotnet:2.1-sdk commands: - dotnet restore --source https://www.nuget.org/api/v1 --source http://nuget-server.tooling/nuget --packages .</description></item></channel></rss>