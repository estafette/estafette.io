<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Estafette on Estafette CI/CD</title><link>https://estafette.io/</link><description>Recent content in Estafette on Estafette CI/CD</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://estafette.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Basics</title><link>https://estafette.io/design/basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/design/basics/</guid><description>Estafette CI leverages Kubernetes as a platform to run concurrent build jobs without being restricted by a set of pre-launched agents. This means it can run hundreds of builds or releases in parallel.
To actually execute build and release actions it takes a pipeline-as-code approach by defining stages in an .estafette.yaml manifest file stored in an application's Git repository. These stages use (public) Docker container images to mount a shared working copy of your applications cloned repository into.</description></item><item><title>Estafette extensions</title><link>https://estafette.io/usage/extensions/estafette-extensions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/usage/extensions/estafette-extensions/</guid><description>extensions/git-clone git-clone: image: extensions/git-clone:stable shallow: &amp;lt; boolean | true &amp;gt; The git-clone stage is automatically injected if not present in your manifest for the build stages; in the release stages it's not injected. In case you don't need anything from your repository to release this speeds things up.
The shallow clone - enabled by default - checks out the latest 50 commits for the particular branch, then selects the correct revision.</description></item><item><title>Installation</title><link>https://estafette.io/getting-started/installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/getting-started/installation/</guid><description>Installing Estafette Prerequisites:
install https://github.com/estafette/estafette-cloudflare-dns install https://github.com/estafette/estafette-letsencrypt-certificate install https://github.com/estafette/k8s-cockroachdb Configure cluster roles and binding:
curl https://raw.githubusercontent.com/estafette/estafette-ci-api/master/rbac.yaml -o rbac.yaml export NAMESPACE=estafette export APP_NAME=estafette-ci-api kubectl apply -f rbac.yaml Install the API:
curl https://raw.githubusercontent.com/estafette/estafette-ci-api/master/kubernetes.yaml -o kubernetes.yaml export NAMESPACE=estafette export APP_NAME=estafette-ci-api export TEAM_NAME=tooling-team export HOSTNAMES=ci.estafette.io export CLOUDFLARE_IP_RANGES=103.21.244.0/22, 103.22.200.0/22, 103.31.4.0/22, 104.16.0.0/12, 108.162.192.0/18, 131.0.72.0/22, 141.101.64.0/18, 162.158.0.0/15, 172.64.0.0/13, 173.245.48.0/20, 188.114.96.0/20, 190.93.240.0/20, 197.234.240.0/22, 198.41.128.0/17 export GITHUB_APP_PRIVATE_KEY= export VERSION=123456 export GO_PIPELINE_LABEL=latest export CPU_REQUEST=10m export MEMORY_REQUEST=15Mi export CPU_LIMIT=200m export MEMORY_LIMIT=512Mi export GITHUB_APP_ID=1234 export GITHUB_APP_OAUTH_CLIENT_ID=ab3.</description></item><item><title>Manifest</title><link>https://estafette.io/usage/manifest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/usage/manifest/</guid><description>Estafette is manifest-controlled. That means each build and stage is controlled via the manifest. No more fiddling in a GUI to set up a pipeline.
Labels Your manifest usually starts with a set of labels; these labels are useful to quickly filter pipelines in the GUI or api, but it also helps for reusing the same application name in your build or release steps.
In the manifest labels can be specified within the labels section; you have full freedom to come up with additional keys for your labels:</description></item><item><title>Vulnerabilities</title><link>https://estafette.io/security/vulnerabilities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/security/vulnerabilities/</guid><description>Detect vulnerabilities at build time When building a container with the extensions/docker image it checks for vulnerabilities automatically and fails on ones with CRITICAL severity.
Upgrade your base image Usually your best of upgrading the image you build FROM to the latest one available. Those are most likely to have their vulnerabilities addressed. And it likely does so in a smaller image.
However that's not always the case - that the latest versions have no vulnerabilities - or this forces you to simultaneously upgrade your programming language SDK which you might not want at this time or slows you down in addressing vulnerabilities in your already running containers.</description></item><item><title>Build an extension</title><link>https://estafette.io/usage/extensions/build-an-extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/usage/extensions/build-an-extension/</guid><description>An Estafette extension is in essence just a containerized application. What's special is that it uses custom properties injected as environment variables to parameterize it's behaviour.
In the example below all non-reserved properties are automatically turned into a environment variable prefixed with ESTAFETTE_EXTENSION_.
bake: image: extensions/docker:dev action: build repositories: - estafette In this example the action property is set as ESTAFETTE_EXTENSION_ACTION on the stage container; the repositories property is set as ESTAFETTE_EXTENSION_REPOSITORIES and it's array items are joined into comma-separated value;</description></item><item><title>Configuration</title><link>https://estafette.io/getting-started/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/getting-started/configuration/</guid><description>Config.yaml While Estafette&amp;lsquo;s goal is to keep as much control as possible with the individual application in the .estafette.yaml manifest, unavoidably there's some configuration that needs to be done centrally. This configuration is stored in the config.yaml file. Below is a description of the various configuration sections.
Integrations For integrations with 3rd party services the integrations section provides a place for configuration for each individual service.
Github In order to receive Github push events Estafette is configured as a Github App and registered to receive push events for all repositories of a specific owner.</description></item><item><title>Goals</title><link>https://estafette.io/design/goals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/design/goals/</guid><description>The goals of Estafette are to&amp;hellip;
control builds and deployments from one concise manifest file. move control over build dependencies to the manifest file. control builds and deployments via cli, slack and web interface. give insight into build times, deployment times, failure rates and more. allow development teams to build their own extensions. support many concurrent builds by leveraging kubernetes jobs. provide resilience against failure during job execution. dogfood its own components by providing different tracks for each (dev, beta, stable/latest).</description></item><item><title>Architecture</title><link>https://estafette.io/design/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/design/architecture/</guid><description>The high-level architecture of Estafette CI looks as follows:
Components API In Estafette CI the api layer is at the heart of the system. It receives events from integrations from the build and release jobs and some other components. The API itself is stateless and runs multiple pods for high availability. It can be upgraded without downtime.
Web The web frontend is a single page application written in VueJS interfacing with the API for it's content.</description></item><item><title>Best practices</title><link>https://estafette.io/usage/best-practices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/usage/best-practices/</guid><description>Pin image tags In order to keep your builds reproducible, even if you haven't touched them for a year it's best to pin the stage image tags as narrowly as possible (or at least major and minor to avoid adopting breaking changes). This will ensure you're not wasting a day figuring out why your build is suddenly broken, when it turns out it's the latest image tag of one of the used images is actually a different image now.</description></item><item><title>Examples</title><link>https://estafette.io/usage/examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://estafette.io/usage/examples/</guid><description>golang labels: app: my-application language: golang stages: build: image: golang:1.11.2-alpine3.8 workDir: /go/src/github.com/estafette/${ESTAFETTE_GIT_NAME} env: CGO_ENABLED: 0 GOOS: linux commands: - go test `go list ./... | grep -v /vendor/` - CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags &amp;#34;-X main.version=${ESTAFETTE_BUILD_VERSION} -X main.revision=${ESTAFETTE_GIT_REVISION} -X main.branch=${ESTAFETTE_GIT_BRANCH} -X main.buildDate=${ESTAFETTE_BUILD_DATETIME}&amp;#34; -o ./publish/${ESTAFETTE_GIT_NAME} . csharp .net core labels: app: my-application language: dotnet-core stages: restore: image: microsoft/dotnet:2.1-sdk commands: - dotnet restore --source https://www.nuget.org/api/v1 --source http://nuget-server.tooling/nuget --packages .nuget/packages build: image: microsoft/dotnet:2.</description></item></channel></rss>